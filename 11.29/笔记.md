### computed
1. computed  具有缓存性

2. computed  是同步的，不能进行异步操作

3. computed  数据和属性来源data数据中，具有多对一的关系

4. 定义：要用的属性不存在，要通过已有属性计算得来

5. 原理：底层借助了Object.defineProperty方法提供的getter和setter

6. get函数什么时候执行？

   (1).初次读取时会执行一次

   (2).当依赖值的数据发生改变时会被调用

7.优势：与methods实现相比，内部有缓存机制，效率更高，调试方便
8.备注：
    (1).计算属性最总会出现在vm上，直接读取使用即可
    (2).如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据

### watch
   ##### 概念：
   当监视的属性变化时，回调函数自动调用，进行相关操作

   监视的属性必须存在，才能监视

   两种写法：
        （1）. new Vue时传入watch配置
        （2）. 通过vm.$watch监视

   原理：底层借助了Object.defineProperty方法提供的getter和setter     

1. Vue中的watch默认不监视对象内部值的改变
2. 配置deep:true 可以监测对象内部值的改变
3. 配置immediate 可以进入页面就立即监听
4. 不存在缓存功能，可以放异步的代码

### methods
  里面放置各种不同的方法函数，只有调用这个方法函数才会返回想要的结果，且不具备缓存功能
   


### 三者的调用与区别

1. methods：必须主动调用，自由调用，且必须加()
   专门执行某项任务，书写业务逻辑
2. computed：通常不会被自由调用，只用于绑定语法中，计算一个值，且不用加()
    结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用
3. watch：不会被自由调用，只有当被监视的变量值改变时，才自动执行，通常不需要有返回值        
    主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是 computed 和 methods 的结合体



### key有什么作用
1. 虚拟DOM中key的作用：
   虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，
   随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较

2. 对比规则：
   1. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
        1. 若虚拟DOM中内容没变，直接使用之前的真实DOM
        2. 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

   2. 旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到页面

3. 用index作为key可能会引发的问题:
   1. 若对数据惊醒：逆序添加、逆序删除等破坏顺序操作。会产生没有必要的真实DOM更新 ===> 界面有问题
   2. 如果结构中还包含输入类的DOM，会产生错误DOM更新===> 界面有问题

4. 开发中如何选择key
   1. 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值
   2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用与渲染列表用于展示，
      使用index作为key是没有问题的  



   